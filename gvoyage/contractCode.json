{
  "contractCode": "pragma solidity 0.5.10;<br />\n<br />\n<br />\nlibrary SafeMath {<br />\n<br />\n&nbsp; &nbsp; function add(uint256 a, uint256 b) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 c = a + b;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(c &gt;= a, \"SafeMath: addition overflow\");<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return c;<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; function sub(uint256 a, uint256 b) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(b &lt;= a, \"SafeMath: subtraction overflow\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 c = a - b;<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return c;<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; function mul(uint256 a, uint256 b) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (a == 0) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 c = a * b;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(c / a == b, \"SafeMath: multiplication overflow\");<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return c;<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; function div(uint256 a, uint256 b) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(b &gt; 0, \"SafeMath: division by zero\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 c = a / b;<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return c;<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; function mod(uint256 a, uint256 b) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return mod(a, b, \"SafeMath: modulo by zero\");<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(b != 0, errorMessage);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return a % b;<br />\n&nbsp; &nbsp; }<br />\n}<br />\ninterface Voyage {<br />\n&nbsp; &nbsp; function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) ;<br />\n&nbsp; &nbsp; function balanceOf(address account) external view returns (uint256) ;<br />\n}<br />\n<br />\ncontract Gvoyage {<br />\n<br />\n&nbsp; &nbsp; using SafeMath for uint256;<br />\n<br />\n&nbsp; &nbsp; uint256 private project_start;<br />\n&nbsp; &nbsp; uint256 public totalInvested;<br />\n&nbsp; &nbsp; uint256 public totalWithdrawn;<br />\n&nbsp; &nbsp; Voyage&nbsp; constant private voyage = Voyage(0xb56dBfE7404817df3EFFc7984d5CC1B72D5609EF);<br />\n&nbsp; &nbsp; address payable constant private token_owner = 0x7e850B5762489cd9555AbaE02c9a5f16b7dF9844;<br />\n&nbsp; &nbsp; address payable constant private root = 0xdb955301fFc8671D302299117e647856aea439aa;<br />\n&nbsp; &nbsp; address payable constant private withdraw_fee = 0x7A8052eB4BE7D3e196E35Be82ED0ce4F1C568433;<br />\n&nbsp; &nbsp; address payable constant private admin_fee = 0x6c4dD4365e27D0E44F2cB0eda355a9E8EEE3fFC2;<br />\n&nbsp; &nbsp; uint256 public assign_weights = 0;<br />\n&nbsp; &nbsp; uint256[16] public investment_grades;<br />\n&nbsp; &nbsp; uint8 private activeLevel = 5;<br />\n&nbsp; &nbsp; uint8 public highestLevelCount = 0;<br />\n&nbsp; &nbsp; uint32 public totalUsers;<br />\n&nbsp; &nbsp; uint16 constant public block_step = 28800;<br />\n&nbsp; &nbsp; uint184 public distribute = 5;<br />\n&nbsp; &nbsp; uint8 public calculation = 5;<br />\n<br />\n&nbsp; &nbsp; struct Deposit {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint8 level;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint248 start;<br />\n<span> </span>uint128 withdrawn;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint128 bonus;<br />\n&nbsp; &nbsp; }<br />\n<br />\n<span> </span>struct User {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256&nbsp; deposit_count;<br />\n<span> </span>&nbsp; &nbsp; uint24[16] user_grade_count;<br />\n<span> </span>Deposit[] deposits;<br />\n<span> </span>address referrer;<br />\n<span> </span>uint256 withdrawn;<br />\n<span> </span>uint256 spot;<br />\n<span> </span>uint256 bonus;<br />\n<span> </span>&nbsp; &nbsp; uint256 deposits_amount;<br />\n<span> </span>}<br />\n<br />\n<span> </span>mapping (address =&gt; User) public users;<br />\n&nbsp; &nbsp; mapping (uint32 =&gt; address) userAddrs;<br />\n<br />\n<span> </span>event NewDeposit(address indexed user,address indexed referrer, uint256 amount);<br />\n<span> </span>event Withdrawn(address indexed user, uint256 amount);<br />\n&nbsp; &nbsp; event Withdrawn_fee(address indexed user, uint256 amount);<br />\n<span> </span>event FeePayed(address indexed user, uint256 totalAmount);<br />\n<span> </span>event _out(address indexed user,uint256 amount);<br />\n<span> </span>event _bonus(address indexed user, uint256 amount);<br />\n<span> </span>event token_transfer(address indexed f, address indexed t,uint256 amount);<br />\n<br />\n&nbsp; &nbsp;constructor()public{<br />\n<br />\n<span> </span>&nbsp; &nbsp; User storage user = users[root];<br />\n<span> </span>&nbsp; &nbsp; totalUsers = 0;<br />\n<span> </span>&nbsp; &nbsp; user.deposits.push(Deposit(0,uint248(block.number),0,0));<br />\n<span> </span>&nbsp; &nbsp; project_start = block.number;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[0] = 3000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[1] = 9000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[2] = 18000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[3] = 30000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[4] = 45000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[5] = 63000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[6] = 84000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[7] = 108000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[8] = 135000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[9] = 165000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[10] = 198000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[11] = 234000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[12] = 273000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[13] = 315000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[14] = 360000 trx;<br />\n<span> </span>&nbsp; &nbsp; investment_grades[15] = 408000 trx;<br />\n<br />\n<span> </span>}<br />\n<br />\n&nbsp; &nbsp;function() payable external {<br />\n<br />\n<span> </span>&nbsp; &nbsp; require(tx.origin == msg.sender,\"Not contract\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; _deposit(root,msg.sender, msg.value,1);<br />\n<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;function deposit(address referrer, uint8 level) payable external {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(tx.origin == msg.sender);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(referrer == address(0)){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _deposit(root,msg.sender,msg.value,level);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _deposit(referrer,msg.sender,msg.value,level);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function withdraw() public {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(tx.origin == msg.sender,\"Not contract\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(address(this).balance &lt;= totalInvested.div(50)){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_termination();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User storage user = users[msg.sender];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(user.deposits.length&gt;0,'User has no dividends');<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 amount = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user.deposits[i],msg.sender == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dividends &gt; user.deposits[i].withdrawn){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user.deposits[i].start = uint128(block.number);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user.deposits[i].bonus = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 draw = dividends.sub(user.deposits[i].withdrawn);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user.deposits[i].withdrawn = uint128(dividends);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount = amount.add(draw);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require(amount &gt; 0,\"No balance to withdraw\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user.withdrawn = user.withdrawn.add(amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _transfer(amount,msg.sender);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emit Withdrawn(msg.sender,amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function out() public {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(address(this).balance &lt;= totalInvested.div(50)){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_termination();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(tx.origin == msg.sender &amp;&amp; msg.sender != root,\"super\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User storage user = users[msg.sender];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(user.deposits.length &gt; 0,\"No deposit to check out\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint8 count = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user.deposits[i],msg.sender == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 amount = investment_grades[user.deposits[i].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 most = amount.mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dividends &gt;= most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count++;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 send = most.sub(user.deposits[i].withdrawn);<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(send &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user.withdrawn = user.withdrawn.add(send);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(send,msg.sender);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;emit _out(msg.sender,amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(count &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(count == user.deposits.length){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete user.deposits;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user.deposits[0] = user.deposits[1];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete user.deposits[1];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user.deposits.length--;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function _transfer(uint256 amount,address payable receive) private {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 last = totalInvested.div(50);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(last &lt; address(this).balance,\"Insufficient Balance\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(amount.add(last) &gt; address(this).balance){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;amount = address(this).balance.sub(last);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;receive.transfer(amount.mul(87).div(100));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;withdraw_fee.transfer(amount.sub(amount.mul(87).div(100)));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;emit Withdrawn_fee(withdraw_fee,amount.mul(13).div(100));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 balance = voyage.balanceOf(token_owner);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 ta = amount.mul(13).div(10000);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(balance &lt; ta){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ta = balance;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(voyage.transferFrom(token_owner,receive,ta),\"token transfer fail\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;emit token_transfer(token_owner,receive,ta);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;totalWithdrawn = totalWithdrawn.add(amount);<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function _deposit(address referrer,address addr, uint256 amount, uint8 level) private {<br />\n<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(totalInvested == 0 || address(this).balance.sub(amount) &gt; totalInvested.div(50),\"project is stop\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(!isContract(addr),\"Not contract\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(addr != root,\"super\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;User storage user = users[addr];<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint8 grade = activeGrades();<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(grade &gt; activeLevel){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;activeLevel = grade;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;highestLevelCount = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require( level &gt; 0 &amp;&amp; level-1 &lt;= grade,\"Invalid investment grade\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(investment_grades[level-1] == amount,\"Unmatched amount\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(level-1 &lt; grade){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(user.user_grade_count[level-1] &lt; 3,\"Investment grade beyond limit\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;require(user.deposits.length &lt; 2,\"Twice at most\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(user.referrer == address(0)){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(referrer != root){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(users[referrer].referrer != address(0), \"recommender does not exist\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user.referrer = referrer;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint32 mod =&nbsp; totalUsers % 100;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;userAddrs[mod] = msg.sender;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;totalUsers ++;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;user.user_grade_count[level-1] = user.user_grade_count[level-1] + 1;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;user.deposits.push(Deposit(level-1,uint248(block.number),0,0));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;user.deposits_amount = amount.add(user.deposits_amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;user.deposit_count = user.deposit_count + 1;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;emit NewDeposit(msg.sender,referrer,amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;referrer = user.referrer;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;totalInvested = totalInvested.add(amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint8 count_spot = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 pot = amount.mul(6).div(2000);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;address up = referrer;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;while(up != address(0) &amp;&amp; count_spot &lt; 20){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User storage user_referrer = users[up];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 award = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(count_spot &lt; level){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 effective = effectiveQuota(up);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(effective &gt;= investment_grades[count_spot]){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;award = award.add(uint256(count_spot+1).mul(300 trx).mul(6));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 spot = pot;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(award.add(spot) &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(user_referrer.deposits.length &gt; 1){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 dividends =&nbsp; calculationDividends(user_referrer.deposits[0],up == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 dep_amount = investment_grades[user_referrer.deposits[0].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 most = dep_amount.mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(dividends.add(award).add(spot) &lt; most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits[0].bonus = uint128(user_referrer.deposits[0].bonus+award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits[0].withdrawn = uint128(user_referrer.deposits[0].withdrawn+spot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.spot = user_referrer.spot.add(spot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toPayAble(up).transfer(spot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}else {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dividends.add(award) &gt;= most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 send = most.sub(user_referrer.deposits[0].withdrawn);<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(send &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.withdrawn = user_referrer.withdrawn.add(send);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(send,toPayAble(up));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; award = award.add(dividends).sub(most);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(award &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.withdrawn = user_referrer.withdrawn.add(award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(award,toPayAble(up));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spot = dividends.add(award).add(spot).sub(most);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; award = 0;<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits[0] = user_referrer.deposits[1];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete user_referrer.deposits[1];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits.length --;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emit _out(up,dep_amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(user_referrer.deposits.length == 1){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(award.add(spot) &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user_referrer.deposits[0],up == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dep_amount = investment_grades[user_referrer.deposits[0].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 most = dep_amount.mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(up == root || dividends.add(award).add(spot) &lt; most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits[0].bonus = uint128(user_referrer.deposits[0].bonus+award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.deposits[0].withdrawn = uint128(user_referrer.deposits[0].withdrawn+pot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.spot = user_referrer.spot.add(pot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toPayAble(up).transfer(pot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(dividends.add(award) &gt;= most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 send = most.sub(user_referrer.deposits[0].withdrawn);<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(send &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.withdrawn = user_referrer.withdrawn.add(send);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(send,toPayAble(up));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(award &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_referrer.withdrawn = user_referrer.withdrawn.add(award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(award,toPayAble(up));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spot = pot.sub(dividends.add(award).add(spot).sub(most));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(spot &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user_referrer.spot = user_referrer.spot.add(spot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;toPayAble(up).transfer(spot);<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emit _out(up,dep_amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete user_referrer.deposits;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_spot ++;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up = user_referrer.referrer;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(count_spot &lt; 20){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 t = pot.mul(20 - count_spot);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;toPayAble(root).transfer(t);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;admin_fee.transfer(amount.mul(4).div(100));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;emit FeePayed(admin_fee,amount.mul(3).div(100));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(level-1 == activeLevel &amp;&amp; highestLevelCount &lt; 50 ){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 award = address(this).balance.div(2000);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user.bonus = user.bonus.add(award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;msg.sender.transfer(award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;highestLevelCount ++;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;emit _bonus(msg.sender,award);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function calculationDividends(Deposit memory dep,bool isRoot) private view returns(uint256){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(isRoot){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return dep.bonus+dep.withdrawn;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 result = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 amount = investment_grades[dep.level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(dep.start &gt; project_start){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = dep.bonus+dep.withdrawn;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 step = block.number.sub(dep.start).div(block_step);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 base = 11 + dep.level;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 mod = step.mod(base.sub(1));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mod = mod.mul(mod.add(1));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 c = step.div(base.sub(1)).mul(base.mul(base.sub(1)));<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = result.add(mod.add(c).mul(amount).div(2000));<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;uint256 most = amount.mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(result &gt; most ){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = most;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return result;<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function effectiveQuota(address addr) private view returns(uint256){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(addr == root){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 408000 trx;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 result = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; User memory user = users[addr];<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(user.deposits.length == 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp;for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 dividends = calculationDividends(user.deposits[i],addr == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 amount = investment_grades[user.deposits[i].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 most = amount.mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(amount &gt; result &amp;&amp; dividends &lt; most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = amount;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return result;<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function _termination() private {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 balance = address(this).balance;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require(balance&gt;0 &amp;&amp; balance &lt;= totalInvested.div(50),\"fail\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(calculation &gt;0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 start = uint8(20*(5-calculation));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 end = start + 20;<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 total = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(uint8 i=start;i&lt;end;i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 effectiv = achievement(userAddrs[i]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(effectiv &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total = total.add(effectiv);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; calculation = calculation - 1;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assign_weights =assign_weights.add(total);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require(distribute &gt; 0,\"fail\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint8 start = uint8(20*(5-distribute));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint8 end = start + 20;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(uint8 i=start; i&lt; end; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint256 effectiv = achievement(userAddrs[i]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(effectiv &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 amount = totalInvested.div(50).mul(effectiv).div(assign_weights);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toPayAble(userAddrs[i]).transfer(amount.mul(87).div(100));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require(voyage.transferFrom(token_owner,userAddrs[i],amount.mul(13).div(10000)),\"token transfer fail\");<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;distribute = distribute - 1;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(distribute == 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;withdraw_fee.transfer(address(this).balance);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;function achievement(address addr) private view returns(uint256 amount){<br />\n&nbsp; &nbsp; &nbsp; &nbsp;User memory user = users[addr];<br />\n&nbsp; &nbsp; &nbsp; &nbsp;if(user.deposits.length &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(uint8 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user.deposits[i],addr == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dep_amount = investment_grades[user.deposits[i].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(dividends &lt; dep_amount.mul(23).div(10)){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;amount = dep_amount.add(amount);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function toPayAble(address addr) private pure returns(address payable){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return address(uint160(addr));<br />\n<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;function isContract(address addr) internal view returns (bool) {<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint size;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; assembly { size := extcodesize(addr) }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return size &gt; 0;<br />\n<br />\n&nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;function poolInfo()external view returns(uint256 balance,uint256 totalInvest,uint256 blockNumber){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return(address(this).balance,totalInvested,block.number);<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function userInfo(address addr) external view returns(uint256 spot,uint256 investAmount,uint256[2] memory amounts,uint256[2] memory dividends,uint256[2] memory staticRate,uint256 bonus){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User memory user = users[addr];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spot = user.spot;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bonus = user.bonus;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(user.deposits.length &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amounts[i] = investment_grades[user.deposits[i].level];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividends[i] = calculationDividends(user.deposits[i],addr == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; investAmount = investAmount.add(investment_grades[user.deposits[i].level]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 step = block.number.sub(user.deposits[i].start).div(block_step);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(step &lt; 1){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; staticRate[i] = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; staticRate[i] = step.mod(uint256(user.deposits[i].level+10));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(staticRate[i] == 0)<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; staticRate[i] = user.deposits[i].level + 10;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function userDespositGrade(address addr) external view returns(uint24[16] memory user_grade_count,uint8&nbsp; activeGrade){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; user_grade_count = users[addr].user_grade_count;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; activeGrade = activeGrades();<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function activeGrades() public view returns(uint8){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 result = block.number.sub(project_start).div(uint256(block_step).mul(30));<br />\n&nbsp; &nbsp; <span> </span>if(result &lt; 1){<br />\n&nbsp; &nbsp; <span> </span>&nbsp; &nbsp; return 4;<br />\n&nbsp; &nbsp; <span> </span>}else if(result&gt;14){<br />\n&nbsp; &nbsp; <span> </span>&nbsp; &nbsp; return 15;<br />\n&nbsp; &nbsp; <span> </span>}else{<br />\n&nbsp; &nbsp; <span> </span>&nbsp; &nbsp; return (uint8)(result.add(4));<br />\n&nbsp; &nbsp; <span> </span>}<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function userFinance(address addr) external view returns(uint256 totalIncome,uint256 tokenTotalIncome,uint256 balance,uint256 tokenBalance){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; User memory user = users[msg.sender];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; uint256 b = 0;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(users[addr].deposits.length &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user.deposits[i],addr == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dividends &gt; user.deposits[i].withdrawn){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = dividends.add(b).sub(user.deposits[i].withdrawn);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; totalIncome = user.withdrawn.add(b).mul(87).div(100);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; tokenTotalIncome = user.withdrawn.add(b).mul(13).div(10000);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(b &gt; 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; balance = b.mul(87).div(100);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tokenBalance = b.mul(13).div(10000);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n&nbsp; &nbsp;function hasToOut(address&nbsp; addr) external view returns(bool){<br />\n<br />\n&nbsp; &nbsp; &nbsp; &nbsp; bool result = false;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; User memory user = users[addr];<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if(addr == root || user.deposits.length == 0){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; for(uint256 i = 0; i &lt; user.deposits.length; i++){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 dividends = calculationDividends(user.deposits[i],addr == root);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 most = investment_grades[user.deposits[i].level].mul(23).div(10);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dividends &gt;= most){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = true;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return result;<br />\n<br />\n&nbsp; &nbsp;}<br />\n<br />\n}<br />"
}